---
title: 并发编程实战2-Synchronized原理与使用
tags: 并发编程,偏向锁,monitor
grammar_cjkRuby: true
---

* Synchronized分类：修饰实例方法、静态方法和代码块
	* 1、放在普通类方法上，内置锁就是实例对象
	* 2、修饰静态方法，内置锁为当前的class字节码对象Sequence.class
	* 3、修饰代码块，内置锁为括号里的对象
	
* 锁分类：偏向锁、轻量级锁和重量级锁
Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。
偏向锁、轻量级锁都是乐观锁，重量级锁是悲观锁。这种设计是为了根据实际的运行状态在不断变化锁的性质，即最开始默认是单线程，即偏向锁，之后如果来了另一个线程就变为轻量级锁，此时两个所冲突并不大，资源是交互使用的。但是，再接着，发现这两个锁总是相互枪资源，就变成重量级锁。  
	* 偏向锁：一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS锁重入，再进行操作。
	* 轻量级锁：一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 
	* 重量级锁：当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。

[内部原理详解博客][1]
[知乎-生动的解释][2]


  [1]: http://www.cnblogs.com/paddix/p/5405678.html
  [2]: https://www.zhihu.com/question/53826114
