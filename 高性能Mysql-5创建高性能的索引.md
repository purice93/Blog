---
title: 高性能Mysql-5创建高性能的索引（上）
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---
==目前而言，对于一般的javaweb框架学习，简单的增删改查数据库就已经够用了。但是数据库的作用并不仅仅是这些，所谓打江山容易，守江山难，找工作很容易，但是如何在工作之后保住饭碗以及如何获得不断地晋升才是最大的问题。同样，一个网站的初期建设是很容易的，但是理论想法和实际应用却相差很远，一旦投入到商业运用，就会由于复杂的实际环境而面临非常大的考验。而这其中，数据库起到了很大的作用。良好的数据库不仅能够加快数据的查询，而且更能很好的在后期进行扩展。==

内容参考：《高性能Mysql》，
背景书目：《淘宝技术这十年》
参考链接：
https://www.ctolib.com/docs-high-performance-mysql-c-1310976.html
http://jm.taobao.org/2011/05/29/951/

----------
一、什么是索引，索引的基础

 * 索引的作用：我的理解，索引相当于c++中的指针，或者java中的引用；更浅显易懂一点，就是你的电话号码，你的门牌标志，它用最少的信息来代表你。这样，可以大大减少数据的存储量。而在数据库中，我们往往申明一列值作为索引，而通过这一列值就可以找到整个数据库的所有信息。
 * 索引的类型：好的索引结构能够大大加快查找的速度，同时大大减少存储量。索引的结构就是数据结构，根据索引结构的不同可以将索引分为以下几类：

二、索引的类别

 1. B-Tree索引
	* 目前而言，一般的数据库都是使用B-Tree索引结构（-不是减+是加！），而B-Tree索引的底层实现往往是B+Tree。对于BTree和B+Tree具体的实现，可以参考数据结构相关的讲解（算法导论）。由于使用了B+Tree，所以每一个叶子节点都爱博涵指向下一个叶子节点的指针，这样就便于也叶子节点的索引。
	* 另外，B-Tree对索引进行顺序存储，也就是说，这种结构很适合进行范围索引（比如查找I-k开头的名字，这样效率会很高）。
	* 由于树这种结构使得查找数据并不需要进行遍历查找，另外由于父节点的指针都存储了子节点的上限和下限，所以能够准确确定查找值所在的子节点，而不需要遍历所有子节点。
	* 这里的索引查找类型省略
	* B-Tree索引的限制和注意：对于多列索引，一定要合理安排索引的列顺序
		
		* 多列索引只能从最左端开始索引，没有最左端后面的都无法和使用；这里的最左端不仅仅包括最左列，还包括最左列的最左的字母。例如：（name，id，age）,不能直接查找age和id，也不能查找以某个字母结尾的name，以某个字母开始的name可以。
		* 同时不能跳过中间的列，上面那个例子，不能没有id而直接索引age
		* 如果前面的列是范围查询，而不是精确的=查询，那么后面的列也是无用的。所以如果实际使用时，如果经常这样查询，就可以在创建索引时，将精确查找列排在最前面；后者是如果范围查找的比较少，可以直接使用=来替代where。
  
 2. 哈希索引
  	* 哈希索引的结构就是哈希表。mysql中只有memory引擎使用了这种结构。记住memory引擎也支持B-Tree索引；而且memory中的哈希索引并不是唯一哈希索引，即当出现哈希冲突时，采用了链表结构来存储。查找name=tom的步骤：首先通过对应的哈希函数f()来定位数据的tom所在的数据行，在对数据行进行链表遍历查找对应的tom。
  	* 哈希索引的限制：限制都是来自于机构，理解了结构就知道了限制原因
  		* 由于哈希只存储哈希值和行指针，所以不能只读取索引的字段，也就不能避免读取整个行（为什么要避免？）
  		* 有结构为哈希函数，所以一定没有顺序存储。也是这个原因，所以只能进行等值查找，即只能使用=、in、<=>，而不能使用where（注：<=>相当于equal()）
  		* 由于哈希函数是将索引整个进行哈希的，所以不能部分索引。如，不能只查找id和name，必须全部都有。
  		* 按道理只要不出现大的哈希冲突，哈希索引是比BTree索引快很多，因为不需要遍历
	* 哈希索引的可能优化：如果某些项被经常索引，就可以在这些项上再加一个BTree索引

 3. 其他索引
 	* 空间索引（R-Tree）：这种方式在《城市计算》这门课中讲述过，这种方式雨里使用了地理数据存储，能对各个维度进行查询。
 	* 全文索引：这种方式相当于搜索引擎，不精确匹配，而是像文本处理那样自己查找关键词
 	* 其他各领域应用不同各有优点
 
 三、索引的优点：不必多言
 四、高性能索引策略
 	* 索引策略是指在索引结构的基础上，实际开发是如何书写mysql语句才能更好的优化查找
 	1. 单列索引
 		* 单列索引即只有一个索引列判断
 		* 一般这样的索引，对于索引列，必须是独立的列，独立的列即这个列是一个整体，既不能是一个表达式也不能是一个函数参数
 		`select actor_id from actor where actor_id+1=5;`
 	2. 前缀索引以及索引选择性
 		* 对于一个索引列，如果索引的数据过长（比如城市名很长），将会大大增加存储空间，我们可以通过截取城市名字符串，只匹配前面的3个字符或者5个字符，这样就大大降低了存储；但是，这样又会导致，查找不精确，因此我们需要权衡。这种合适的长度需要我们根据实际开发时用到的数据，自己进行测试，找到最合适的。
 	3. 多列索引
 		* 对于多列索引，这里就需要考虑BTree的结构，前面已经讲过
 		* 将确定的列放在前面
 		* 将分辨率最大的列放在前面（分辨率最大即能筛选出大部分的值，留下的值最少），同样，需要实际测试，选择合适的
 	4. 聚簇索引
 		* 书上说这种索引其实是一种数据存储方式，但是我理解的是，这是一种存储方式和索引的结合。即在BTree索引的基础上，索引时没有了指向数据的指针，而是直接将数据行保存在叶子节点中。想一想这样的好处是什么？这部分书上没讲清楚，说说我的理解。举个例子：如果我们需要根据ID查找某个人的邮件，如果只是BTree索引，我们需要将查到的条数一条一条进行IO读取；使用了聚簇索引后，由于它的存储结构是叶子也存储了行的全部数据，节点页只包含索引，即ID用户所对应的邮箱数据是存在一起的，所以如果我们查找到了某个ID节点，就可以一次性全部读取。（理解可能有误，还需要再看）
 		* InnoDB和MyISAM的数据分布对比：同时，簇聚索引也有一些缺点：更新簇聚索引列的代价很高，因为会强制InnoDB将每个被更新的列移动到新的位置；（可能有页分裂问题，也就是树的变动）
 	5. 覆盖索引
 		* 通常大家设计索引都会根据查询的WHERE条件来创建合适的索引，不过这只是索引优化的一个方面。设计优秀的索引应该考虑整个查询，而不单单是WHERE条件部分。如果一个索引中包含了所需要查询的字段的值，我们就称为“覆盖索引”，覆盖索引能够极大的提高性能，覆盖索引带来的好处有：索引条目远小于数据行大小，能够极大地提高性能，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量
 		* 我的理解，覆盖索引有点像聚簇索引，它的原理可能是将需要查找的数据包含在索引里面，这样就不需要通过索引指针去查找扫描所有的列元素，减少了io。
 			
